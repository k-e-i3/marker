<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ»ãƒãƒ¼ã‚«ãƒ¼å¼æš—è¨˜ãƒ„ãƒ¼ãƒ« v3.0</title>
    <style>
        :root {
            --bg-color: #f4f4f9; --main-bg: #ffffff; --rule-bg: #eef1f5;
            --text-color: #333; --border-color: #d1d9e6; --header-bg: #2d3748;
            --header-text: #ffffff; --button-bg: #4a5568; --button-hover-bg: #2d3748;
            --highlight-bg: #fffde7; --speech-highlight-bg: #fdff32;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Hiragino Sans', 'Noto Sans CJK JP', sans-serif;
            margin: 0; background-color: var(--bg-color); color: var(--text-color);
            display: flex; flex-direction: column; height: 100vh; overflow: hidden;
        }
        header {
            background-color: var(--header-bg); color: var(--header-text); padding: 10px 15px;
            display: flex; align-items: center; flex-wrap: wrap; gap: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); flex-shrink: 0; z-index: 10;
        }
        header h1 { font-size: 1.1em; margin: 0; }
        .control-group { display: flex; align-items: center; gap: 5px; }
        select, input, button {
            font-size: 14px; padding: 6px 12px; border-radius: 5px;
            border: 1px solid #718096; background-color: #edf2f7; color: #2d3748;
        }
        button {
            background-color: var(--button-bg); color: var(--header-text); cursor: pointer;
            border-color: transparent; transition: background-color 0.2s;
        }
        button:hover { background-color: var(--button-hover-bg); }
        main {
            display: flex; flex-direction: column; flex-grow: 1;
            padding: 15px; gap: 15px; overflow: hidden; position: relative;
        }
        .panel {
            background-color: var(--main-bg); border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05); border: 1px solid var(--border-color);
            display: flex; flex-direction: column; overflow: hidden;
        }
        .panel.main { flex-grow: 1; position: relative; }
        .panel.manager { flex-shrink: 0; height: 200px; transition: height 0.3s ease; }
        .panel.manager.closed { height: 42px; }
        .panel-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 15px; border-bottom: 1px solid var(--border-color);
            background-color: #f9fafb; cursor: pointer; user-select: none;
        }
        .panel-header h2 { font-size: 1em; margin: 0; }
        #main-text-area {
            flex-grow: 1; padding: 15px; font-size: 18px; line-height: 1.8;
            white-space: pre-wrap; word-wrap: break-word; overflow-y: auto; outline: none;
        }
        #marker-manager-list { overflow-y: auto; padding: 10px; }
        .manager-item {
            display: flex; align-items: center; padding: 8px;
            border-bottom: 1px solid #e2e8f0; font-size: 14px;
            cursor: pointer; transition: background-color 0.2s;
        }
        .manager-item:hover { background-color: #f7fafc; }
        .manager-item-icon { font-size: 1.2em; min-width: 30px; text-align: center; }
        .manager-item-text { flex-grow: 1; font-weight: bold; color: #2d3748; }
        .manager-item-context { color: #718096; font-size: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .manager-item-delete {
            background: none; border: none; font-size: 1.2em; cursor: pointer;
            color: #a0aec0; transition: color 0.2s; padding: 5px;
        }
        .manager-item-delete:hover { color: #e53e3e; }

        .marker { cursor: pointer; border-radius: 3px; user-select: none; letter-spacing: 0.05em; }
        .marker.reveal { background-color: var(--highlight-bg); letter-spacing: normal; }
        .marker.jump-highlight { animation: jump-highlight 1.5s ease; }
        @keyframes jump-highlight { 0% { background-color: #f6e05e; } 100% { background-color: transparent; } }

        #mini-palette {
            position: absolute; background-color: #333; padding: 8px; border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2); display: none; gap: 5px; z-index: 100;
        }
        .mini-palette-item {
            width: 32px; height: 32px; cursor: pointer; border: 2px solid transparent; border-radius: 6px;
            display: flex; justify-content: center; align-items: center; font-size: 22px; transition: transform 0.1s;
        }
        .mini-palette-item:hover { transform: scale(1.15); background-color: #555; }

        #modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.6); z-index: 1000;
            display: none; justify-content: center; align-items: center;
        }
        .modal-content {
            background-color: #fff; padding: 20px; border-radius: 8px;
            width: 80%; max-width: 700px; display: flex;
            flex-direction: column; gap: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .modal-content textarea { height: 40vh; border: 1px solid #ccc; font-family: monospace; }
        .modal-buttons { display: flex; gap: 10px; justify-content: flex-end; }
        .modal-choices { display: flex; gap: 10px; justify-content: center; margin-bottom: 15px; }
        .modal-choices button { padding: 10px 20px; font-size: 16px; }
    </style>
</head>
<body>
    <header>
        <h1>ãƒãƒ¼ã‚«ãƒ¼å¼æš—è¨˜ãƒ„ãƒ¼ãƒ« v3.0</h1>
        <div class="control-group">
            <select id="doc-select"></select>
            <button id="rename-doc-btn" title="ã‚¿ã‚¤ãƒˆãƒ«ã‚’ç·¨é›†">ğŸ“</button>
        </div>
        <div class="control-group">
            <span id="char-counter" style="min-width: 100px;">æ–‡å­—æ•°: 0</span>
        </div>
        <div class="control-group">
            <button id="speech-btn">â–¶ èª­ã¿ä¸Šã’</button>
            <select id="voice-select" style="display:none;"></select>
        </div>
        <div class="control-group">
            <button id="copy-text-btn">ğŸ“„ åŸæ–‡ã‚³ãƒ”ãƒ¼</button>
            <button id="sync-btn">ğŸ”„ å…¨ãƒ‡ãƒ¼ã‚¿åŒæœŸ</button>
        </div>
    </header>

    <main>
        <div id="mini-palette"></div>
        <div class="panel main">
            <div id="main-text-area" contenteditable="true" spellcheck="false"></div>
        </div>
        <div class="panel manager" id="manager-panel">
            <div class="panel-header" id="manager-header">
                <h2>ãƒãƒ¼ã‚«ãƒ¼ãƒ»ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼</h2>
                <span id="toggle-manager-btn">â–¼ é–‰ã˜ã‚‹</span>
            </div>
            <div id="marker-manager-list"></div>
        </div>
    </main>
    
    <div id="modal-overlay">
        <div class="modal-content" id="sync-modal">
            <h3 id="modal-title"></h3>
            <div id="modal-choices" class="modal-choices">
                 <button id="export-choice-btn">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ (ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ)</button>
                 <button id="import-choice-btn">ã‚¤ãƒ³ãƒãƒ¼ãƒˆ (ãƒ‡ãƒ¼ã‚¿å¾©å…ƒ)</button>
            </div>
            <p id="modal-desc"></p>
            <textarea id="io-textarea"></textarea>
            <div class="modal-buttons">
                <button id="io-action-btn"></button>
                <button id="close-modal-btn">é–‰ã˜ã‚‹</button>
            </div>
        </div>
    </div>

    <script>
    class MarkerToolV3 {
        constructor() {
            // DOM Elements
            this.docSelect = document.getElementById('doc-select');
            this.renameDocBtn = document.getElementById('rename-doc-btn');
            this.mainTextArea = document.getElementById('main-text-area');
            this.markerManagerList = document.getElementById('marker-manager-list');
            this.charCounter = document.getElementById('char-counter');
            this.speechBtn = document.getElementById('speech-btn');
            this.voiceSelect = document.getElementById('voice-select');
            this.managerPanel = document.getElementById('manager-panel');
            this.managerHeader = document.getElementById('manager-header');
            this.toggleManagerBtn = document.getElementById('toggle-manager-btn');
            this.miniPalette = document.getElementById('mini-palette');
            this.copyTextBtn = document.getElementById('copy-text-btn');
            this.syncBtn = document.getElementById('sync-btn');
            
            // Modal Elements
            this.modalOverlay = document.getElementById('modal-overlay');
            this.modalTitle = document.getElementById('modal-title');
            this.modalDesc = document.getElementById('modal-desc');
            this.modalChoices = document.getElementById('modal-choices');
            this.ioTextarea = document.getElementById('io-textarea');
            this.ioActionBtn = document.getElementById('io-action-btn');
            this.closeModalBtn = document.getElementById('close-modal-btn');
            this.exportChoiceBtn = document.getElementById('export-choice-btn');
            this.importChoiceBtn = document.getElementById('import-choice-btn');
            
            // Marker Styles
            this.markerStyles = [
                { type: 'E', value: 'â¬œ' }, { type: 'E', value: 'ğŸ' }, { type: 'E', value: 'ğŸ™' },
                { type: 'E', value: 'ğŸ˜€' }, { type: 'E', value: 'ğŸ¸' }, { type: 'E', value: 'ğŸ‘½' },
                { type: 'E', value: 'ğŸ§Ÿâ€â™€ï¸' }, { type: 'E', value: 'ğŸ¥¶' }, { type: 'E', value: 'ğŸŒ' },
                { type: 'E', value: 'ğŸ’©' }, { type: 'E', value: 'ğŸ‡' }, { type: 'E', value: 'ğŸ€' }
            ];

            // App State
            this.state = {
                anchorLength: 10,
                isSpeaking: false,
                voices: [],
                appData: {},
                currentDocIndex: 0,
                selectionRange: null,
            };
            
            this.DOC_COUNT = 20;
            this.init();
        }

        init() {
            this.createMiniPalette();
            this.loadState();
            this.initSpeech();
            this.bindEvents();
            this.updateDocSelect();
            this.updateDocumentView();
        }

        bindEvents() {
            this.mainTextArea.addEventListener('mouseup', (e) => this.handleSelection(e));
            this.mainTextArea.addEventListener('input', () => this.updateCharCount());
            document.addEventListener('click', (e) => {
                if (!this.miniPalette.contains(e.target) && !this.mainTextArea.contains(e.target)) {
                    this.hideMiniPalette();
                }
            });
            
            this.docSelect.addEventListener('change', (e) => this.switchDocument(parseInt(e.target.value, 10)));
            this.renameDocBtn.addEventListener('click', () => this.renameDocument());
            this.managerHeader.addEventListener('click', () => this.toggleManagerPanel());
            
            this.copyTextBtn.addEventListener('click', () => this.copyPlainText());
            this.syncBtn.addEventListener('click', () => this.openSyncModal());
            this.exportChoiceBtn.addEventListener('click', () => this.setupExportModal());
            this.importChoiceBtn.addEventListener('click', () => this.setupImportModal());
            this.closeModalBtn.addEventListener('click', () => this.closeSyncModal());
            this.ioActionBtn.addEventListener('click', () => this.handleIoAction());
        }

        createMiniPalette() {
            this.markerStyles.forEach(style => {
                const item = document.createElement('div');
                item.className = 'mini-palette-item';
                item.textContent = style.value;
                item.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.createMarkerFromPalette(style);
                });
                this.miniPalette.appendChild(item);
            });
        }
        
        handleSelection(e) {
            // (v2.2 logic remains)
            const selection = window.getSelection();
            if (!selection.rangeCount || selection.isCollapsed || !selection.toString().trim()) {
                this.hideMiniPalette();
                return;
            }
            this.state.selectionRange = selection.getRangeAt(0).cloneRange();
            const rect = this.state.selectionRange.getBoundingClientRect();
            this.showMiniPalette(rect.left + window.scrollX, rect.top + window.scrollY);
        }

        showMiniPalette(x, y) {
            this.miniPalette.style.display = 'flex';
            this.miniPalette.style.left = `${x}px`;
            this.miniPalette.style.top = `${y - 60}px`;
        }
        
        hideMiniPalette() {
            this.miniPalette.style.display = 'none';
            this.state.selectionRange = null;
        }

        createMarkerFromPalette(style) {
            if (!this.state.selectionRange) return;

            const hiddenText = this.state.selectionRange.toString().trim();
            const preRange = document.createRange();
            preRange.setStart(this.state.selectionRange.startContainer, 0);
            preRange.setEnd(this.state.selectionRange.startContainer, this.state.selectionRange.startOffset);
            const prefix = preRange.toString().slice(-this.state.anchorLength);

            const postRange = document.createRange();
            postRange.setStart(this.state.selectionRange.endContainer, this.state.selectionRange.endOffset);
            postRange.setEnd(this.state.selectionRange.endContainer, this.state.selectionRange.endContainer.length);
            const suffix = postRange.toString().slice(0, this.state.anchorLength);

            const styleString = `%% ${style.type}${style.value}`;
            const rule = `${this.state.currentDocIndex} :: ${prefix.trim()}...${suffix.trim()} -> ${hiddenText} ${styleString}`;
            
            const currentRules = this.state.appData.rules.split('\n').filter(Boolean);
            currentRules.push(rule);
            this.state.appData.rules = currentRules.join('\n');
            
            this.applyRules();
            this.hideMiniPalette();
            window.getSelection().removeAllRanges();
        }

        applyRules() {
            const originalText = this.getOriginalText();
            this.state.appData.documents[this.state.currentDocIndex].content = originalText;
            
            this.mainTextArea.innerHTML = '';
            
            let segments = [{ text: originalText, type: 'text' }];

            const allRules = this.state.appData.rules.split('\n').filter(Boolean);
            const targetRules = allRules.filter(rule => rule.startsWith(this.state.currentDocIndex + ' ::'));
            
            targetRules.forEach(rule => {
                try {
                    const ruleParts = rule.split(' -> ');
                    const hiddenTextAndStyle = ruleParts[1].split(' %% ');
                    const hiddenText = hiddenTextAndStyle[0];
                    const styleString = hiddenTextAndStyle[1];
                    const anchorParts = ruleParts[0].split(' :: ')[1].split('...');
                    const prefix = anchorParts[0];
                    const suffix = anchorParts[1];
                    const fullAnchor = prefix + hiddenText + suffix;
                    
                    for (let i = 0; i < segments.length; i++) {
                        if (segments[i].type === 'text') {
                            const index = segments[i].text.indexOf(fullAnchor);
                            if (index > -1) {
                                const before = segments[i].text.substring(0, index + prefix.length);
                                const after = segments[i].text.substring(index + prefix.length + hiddenText.length);
                                segments.splice(i, 1, { text: before, type: 'text' }, { text: hiddenText, type: 'marker', style: styleString, fullRule: rule }, { text: after, type: 'text' });
                                break;
                            }
                        }
                    }
                } catch(e) { /* ignore parse error */ }
            });

            segments.forEach(seg => {
                if (seg.type === 'text') {
                    this.mainTextArea.appendChild(document.createTextNode(seg.text));
                } else if(seg.type === 'marker') {
                    const markerSpan = document.createElement('span');
                    markerSpan.className = 'marker';
                    markerSpan.dataset.originalText = seg.text;
                    markerSpan.dataset.style = seg.style;
                    markerSpan.dataset.fullRule = seg.fullRule;
                    
                    const type = seg.style.charAt(0);
                    const value = seg.style.substring(1);
                    if (type === 'E') {
                        markerSpan.textContent = value.repeat(seg.text.length);
                    }
                    this.mainTextArea.appendChild(markerSpan);
                }
            });

            this.mainTextArea.innerHTML = this.mainTextArea.innerHTML.replace(/\n/g, '<br>');
            this.renderMarkerManager();
            this.updateCharCount();
            this.saveState();
        }

        renderMarkerManager() {
            this.markerManagerList.innerHTML = '';
            const allRules = this.state.appData.rules.split('\n').filter(Boolean);
            const targetRules = allRules.filter(rule => rule.startsWith(this.state.currentDocIndex + ' ::'));

            if(targetRules.length === 0) {
                this.markerManagerList.innerHTML = '<p style="text-align:center; color:#718096; padding: 20px;">ãƒãƒ¼ã‚«ãƒ¼ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>';
                return;
            }

            targetRules.forEach(rule => {
                const item = document.createElement('div');
                item.className = 'manager-item';
                item.dataset.fullRule = rule;

                const ruleParts = rule.split(' -> ');
                const hiddenTextAndStyle = ruleParts[1].split(' %% ');
                const hiddenText = hiddenTextAndStyle[0];
                const styleString = hiddenTextAndStyle[1];
                const anchorText = ruleParts[0].split(' :: ')[1];

                const icon = styleString.substring(1).repeat(1);
                
                item.innerHTML = `
                    <div class="manager-item-icon">${icon}</div>
                    <div class="manager-item-details">
                        <div class="manager-item-text">${hiddenText}</div>
                        <div class="manager-item-context">${anchorText.replace('...', ' ... ')}</div>
                    </div>
                    <button class="manager-item-delete" title="ã“ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’å‰Šé™¤">ğŸ—‘ï¸</button>
                `;

                item.querySelector('.manager-item-delete').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.removeRule(rule);
                });
                
                item.addEventListener('click', () => this.jumpToMarker(rule));

                this.markerManagerList.appendChild(item);
            });
        }
        
        removeRule(ruleToRemove) {
            const allRules = this.state.appData.rules.split('\n');
            const newRules = allRules.filter(rule => rule !== ruleToRemove);
            this.state.appData.rules = newRules.join('\n');
            this.applyRules();
        }

        jumpToMarker(rule) {
            const markerInDom = this.mainTextArea.querySelector(`.marker[data-full-rule="${rule}"]`);
            if (markerInDom) {
                markerInDom.scrollIntoView({ behavior: 'smooth', block: 'center' });
                markerInDom.classList.remove('jump-highlight'); // remove for re-trigger
                void markerInDom.offsetWidth; // trigger reflow
                markerInDom.classList.add('jump-highlight');
            }
        }
        
        // --- Data Sync and Management ---

        copyPlainText() {
            const text = this.getOriginalText();
            navigator.clipboard.writeText(text).then(() => {
                alert("åŸæ–‡ã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚");
            });
        }
        
        openSyncModal() {
            this.modalOverlay.style.display = 'flex';
            this.modalTitle.textContent = "å…¨ãƒ‡ãƒ¼ã‚¿åŒæœŸ";
            this.modalChoices.style.display = 'flex';
            this.modalDesc.innerHTML = '';
            this.ioTextarea.style.display = 'none';
            this.ioActionBtn.style.display = 'none';
        }

        setupExportModal() {
            this.modalChoices.style.display = 'none';
            this.modalDesc.innerHTML = '<strong>ã“ã®ãƒ†ã‚­ã‚¹ãƒˆãŒã‚ãªãŸã®å…¨ãƒ‡ãƒ¼ã‚¿ã§ã™ã€‚</strong><br>ã“ã‚Œã‚’å…¨ã¦ã‚³ãƒ”ãƒ¼ã—ã€å®‰å…¨ãªå ´æ‰€ã«ä¿ç®¡ã™ã‚‹ã‹ã€ä»–ã®ãƒ‡ãƒã‚¤ã‚¹ã§ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ãã ã•ã„ã€‚';
            this.ioTextarea.value = JSON.stringify(this.state.appData, null, 2);
            this.ioTextarea.readOnly = true;
            this.ioTextarea.style.display = 'block';
            this.ioActionBtn.textContent = "ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼";
            this.ioActionBtn.style.display = 'block';
        }
        
        setupImportModal() {
            this.modalChoices.style.display = 'none';
            this.modalDesc.innerHTML = '<strong>æ³¨æ„ï¼šç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã¯ä¸Šæ›¸ãã•ã‚Œã¾ã™ã€‚</strong><br>ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’ã“ã“ã«è²¼ã‚Šä»˜ã‘ã¦ã€ã€Œèª­ã¿è¾¼ã‚€ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚';
            this.ioTextarea.value = '';
            this.ioTextarea.readOnly = false;
            this.ioTextarea.style.display = 'block';
            this.ioActionBtn.textContent = "ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€";
            this.ioActionBtn.style.display = 'block';
        }

        closeSyncModal() { this.modalOverlay.style.display = 'none'; }
        
        handleIoAction() {
            if (this.ioActionBtn.textContent.includes('ã‚³ãƒ”ãƒ¼')) {
                navigator.clipboard.writeText(this.ioTextarea.value).then(() => {
                    this.ioActionBtn.textContent = "ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼";
                    setTimeout(() => this.ioActionBtn.textContent = "ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼", 2000);
                });
            } else { // Import
                if(!confirm("æœ¬å½“ã«ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä¸Šæ›¸ãã—ã¾ã™ã‹ï¼Ÿã“ã®æ“ä½œã¯å…ƒã«æˆ»ã›ã¾ã›ã‚“ã€‚")) return;
                try {
                    const newData = JSON.parse(this.ioTextarea.value);
                    if (newData.documents && Array.isArray(newData.documents) && typeof newData.rules === 'string') {
                        this.state.appData = newData;
                        this.state.currentDocIndex = 0;
                        this.saveState();
                        this.updateDocSelect();
                        this.updateDocumentView();
                        this.closeSyncModal();
                        alert("ãƒ‡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«æˆåŠŸã—ã¾ã—ãŸã€‚");
                    } else { throw new Error("Invalid data structure"); }
                } catch (e) { alert("ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚"); }
            }
        }
        
        renameDocument() {
            const currentTitle = this.state.appData.documents[this.state.currentDocIndex].title;
            const newTitle = prompt("æ–°ã—ã„ã‚¿ã‚¤ãƒˆãƒ«ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:", currentTitle);
            if (newTitle && newTitle.trim()) {
                this.state.appData.documents[this.state.currentDocIndex].title = newTitle.trim();
                this.updateDocSelect();
                this.saveState();
            }
        }

        // --- State and UI Updates ---
        
        updateCharCount() {
            const count = this.getOriginalText().length;
            this.charCounter.textContent = `æ–‡å­—æ•°: ${count}`;
        }
        
        updateDocSelect() {
            this.docSelect.innerHTML = '';
            this.state.appData.documents.forEach((doc, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = doc.title;
                this.docSelect.appendChild(option);
            });
            this.docSelect.value = this.state.currentDocIndex;
        }

        switchDocument(docIndex) {
            this.state.appData.documents[this.state.currentDocIndex].content = this.getOriginalText();
            this.state.currentDocIndex = docIndex;
            this.updateDocumentView();
        }

        updateDocumentView() {
            this.docSelect.value = this.state.currentDocIndex;
            const currentDoc = this.state.appData.documents[this.state.currentDocIndex];
            this.mainTextArea.textContent = currentDoc.content;
            this.applyRules(); // This will also save state
        }
        
        getOriginalText() {
            // (v2.2 logic remains)
            const tempDiv = document.createElement('div');
            this.mainTextArea.childNodes.forEach(node => {
                if (node.nodeType === Node.TEXT_NODE) {
                    tempDiv.appendChild(node.cloneNode());
                } else if (node.nodeName === 'SPAN' && node.classList.contains('marker')) {
                    tempDiv.appendChild(document.createTextNode(node.dataset.originalText));
                } else if (node.nodeName === 'BR') {
                    tempDiv.appendChild(document.createTextNode('\n'));
                }
            });
            return tempDiv.textContent || '';
        }

        saveState() {
            // ç¾åœ¨ã®æœ¬æ–‡ã‚’ä¿å­˜
            if (this.state.appData.documents[this.state.currentDocIndex]) {
                 this.state.appData.documents[this.state.currentDocIndex].content = this.getOriginalText();
            }
            localStorage.setItem('markerToolState_v3_0', JSON.stringify(this.state.appData));
        }

        loadState() {
            const savedState = localStorage.getItem('markerToolState_v3_0');
            if (savedState) {
                try {
                    const data = JSON.parse(savedState);
                    if (data.documents && Array.isArray(data.documents)) {
                        this.state.appData = data;
                    } else { this.resetData(); }
                } catch(e) { this.resetData(); }
            } else { this.resetData(); }

            // Ensure doc count is correct
            while(this.state.appData.documents.length < this.DOC_COUNT) {
                const newIndex = this.state.appData.documents.length + 1;
                this.state.appData.documents.push({ title: `æ–‡ç«  ${newIndex}`, content: `` });
            }
            this.state.appData.documents = this.state.appData.documents.slice(0, this.DOC_COUNT);
        }

        resetData() {
            this.state.appData = { documents: [], rules: '' };
            for(let i=1; i<=this.DOC_COUNT; i++) {
                this.state.appData.documents.push({ title: `æ–‡ç«  ${i}`, content: `` });
            }
        }
        
        // --- Other methods (mostly from v2.2) ---
        toggleManagerPanel() { this.managerPanel.classList.toggle('closed'); this.toggleManagerBtn.textContent = this.managerPanel.classList.contains('closed') ? 'â–² é–‹ã' : 'â–¼ é–‰ã˜ã‚‹'; }
        initSpeech() { /* Dummy */ }
        toggleSpeech() { alert("èª­ã¿ä¸Šã’æ©Ÿèƒ½ã¯ç¾åœ¨èª¿æ•´ä¸­ã§ã™ã€‚"); }
    }

    new MarkerToolV3();
    </script>
</body>
</html>
