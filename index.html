<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ»ãƒãƒ¼ã‚«ãƒ¼å¼æš—è¨˜ãƒ„ãƒ¼ãƒ« v2.1</title>
    <style>
        :root {
            --bg-color: #f4f4f9;
            --main-bg: #ffffff;
            --rule-bg: #eef1f5;
            --text-color: #333;
            --border-color: #d1d9e6;
            --header-bg: #4a6fa5;
            --header-text: #ffffff;
            --button-bg: #5a85c8;
            --highlight-bg: #fffde7; /* ç­”ãˆè¡¨ç¤ºæ™‚ã®èƒŒæ™¯è‰² */
            --speech-highlight-bg: #fdff32;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Hiragino Sans', 'Noto Sans CJK JP', sans-serif;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        header {
            background-color: var(--header-bg);
            color: var(--header-text);
            padding: 10px 20px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex-shrink: 0;
            z-index: 10;
        }
        header h1 {
            font-size: 1.2em;
            margin: 0;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        select, input, button {
            font-size: 14px;
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: #f0f8ff;
        }
        button {
            background-color: var(--button-bg);
            color: var(--header-text);
            cursor: pointer;
            border-color: transparent;
        }
        button:hover {
            opacity: 0.9;
        }
        main {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            padding: 15px;
            gap: 15px;
            overflow: hidden;
        }
        .panel {
            background-color: var(--main-bg);
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .panel.main {
            flex-grow: 1;
        }
        .panel.rules {
            flex-shrink: 0;
            height: 150px;
            transition: height 0.3s ease;
        }
        .panel.rules.closed {
            height: 40px;
        }
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-color);
            background-color: #f9fafb;
            cursor: pointer;
        }
        .panel-header h2 {
            font-size: 1em;
            margin: 0;
        }
        textarea, #main-text-area {
            flex-grow: 1;
            border: none;
            padding: 15px;
            font-size: 18px;
            line-height: 1.8;
            resize: none;
            outline: none;
            background-color: transparent;
            font-family: inherit;
        }
        #main-text-area {
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-y: auto;
        }
        #rules-text-area {
            background-color: var(--rule-bg);
            font-family: monospace;
            font-size: 13px;
            line-height: 1.6;
        }
        .marker {
            cursor: pointer;
            border-radius: 3px;
            user-select: none;
            letter-spacing: 0.05em; /* çµµæ–‡å­—é–“ã®å°‘ã—ã®ã‚¹ãƒšãƒ¼ã‚¹ */
        }
        .marker.reveal {
            background-color: var(--highlight-bg);
            letter-spacing: normal;
        }
        .speech-highlight {
            background-color: var(--speech-highlight-bg);
            border-radius: 3px;
        }
        .marker-palette {
            display: flex;
            gap: 5px;
            align-items: center;
            background-color: #e3eaf3;
            padding: 5px 8px;
            border-radius: 6px;
        }
        .palette-item {
            width: 28px;
            height: 28px;
            cursor: pointer;
            border: 2px solid transparent;
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            transition: transform 0.1s;
        }
        .palette-item:hover {
            transform: scale(1.1);
        }
        .palette-item.selected {
            border-color: #007bff;
            background-color: #fff;
        }
    </style>
</head>
<body>
    <header>
        <h1>ãƒãƒ¼ã‚«ãƒ¼å¼æš—è¨˜ãƒ„ãƒ¼ãƒ« v2.1</h1>
        <div class="control-group">
            <label for="doc-select">æ–‡ç« :</label>
            <select id="doc-select">
                <option value="doc1">æ–‡ç« â‘ </option>
                <option value="doc2">æ–‡ç« â‘¡</option>
                <option value="doc3">æ–‡ç« â‘¢</option>
            </select>
        </div>
        <div class="control-group">
            <button id="speech-btn">â–¶ èª­ã¿ä¸Šã’</button>
            <select id="voice-select"></select>
        </div>
        <div class="marker-palette">
            <!-- ãƒãƒ¼ã‚«ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆãŒã“ã“ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
        </div>
    </header>

    <main>
        <div class="panel main">
             <div class="panel-header" style="cursor: default;">
                <h2>1. ã“ã“ã«æ–‡ç« ã‚’è²¼ã‚Šä»˜ã‘ã€ä¸‹ã®ãƒ‘ãƒ¬ãƒƒãƒˆã‹ã‚‰ãƒãƒ¼ã‚«ãƒ¼ã‚’é¸ã‚“ã§å¼•ã</h2>
            </div>
            <div id="main-text-area" contenteditable="true" spellcheck="false"></div>
        </div>
        <div class="panel rules" id="rules-panel">
            <div class="panel-header" id="rules-header">
                <h2>2. ãƒãƒ¼ã‚«ãƒ¼ã®ãƒ«ãƒ¼ãƒ« (ä»–ãƒ‡ãƒã‚¤ã‚¹ã«ã‚³ãƒ”ãƒšã§åŒæœŸ)</h2>
                <span id="toggle-rules-btn">â–¼ é–‰ã˜ã‚‹</span>
            </div>
            <textarea id="rules-text-area" placeholder="æ–‡ç« ã®ä¸Šã§ãƒ†ã‚­ã‚¹ãƒˆã‚’é¸æŠã—ã¦ãƒãƒ¼ã‚«ãƒ¼ã‚’å¼•ãã¨ã€ã“ã“ã«ãƒ«ãƒ¼ãƒ«ãŒè‡ªå‹•ç”Ÿæˆã•ã‚Œã¾ã™ã€‚"></textarea>
        </div>
    </main>

    <script>
    class MarkerToolV2_1 {
        constructor() {
            // DOMè¦ç´ 
            this.mainTextArea = document.getElementById('main-text-area');
            this.rulesTextArea = document.getElementById('rules-text-area');
            this.docSelect = document.getElementById('doc-select');
            this.speechBtn = document.getElementById('speech-btn');
            this.voiceSelect = document.getElementById('voice-select');
            this.rulesPanel = document.getElementById('rules-panel');
            this.rulesHeader = document.getElementById('rules-header');
            this.toggleRulesBtn = document.getElementById('toggle-rules-btn');
            this.markerPaletteContainer = document.querySelector('.marker-palette');
            
            // ãƒãƒ¼ã‚«ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ (ã”æŒ‡å®šã®çµµæ–‡å­—ã«å¤‰æ›´)
            this.markerStyles = [
                { type: 'E', value: 'ğŸ˜€' }, { type: 'E', value: 'ğŸŒ²' },
                { type: 'E', value: 'ğŸ°' }, { type: 'E', value: 'ğŸ—»' },
                { type: 'E', value: 'ğŸš„' }, { type: 'E', value: 'ğŸš™' },
                { type: 'E', value: 'ğŸ' }, { type: 'E', value: 'ğŸ’€' }
            ];

            // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹
            this.state = {
                currentDocId: 'doc1',
                anchorLength: 7,
                documents: {},
                lastTap: 0,
                lastClickedMarker: null,
                selectedMarkerStyle: this.markerStyles[0],
                isSpeaking: false,
                voices: []
            };

            this.init();
        }

        init() {
            this.createMarkerPalette();
            this.loadState();
            this.initSpeech();
            this.bindEvents();
            this.updateDocumentView();
        }

        createMarkerPalette() {
            this.markerStyles.forEach(style => {
                const item = document.createElement('div');
                item.className = 'palette-item';
                item.textContent = style.value;
                item.addEventListener('click', () => {
                    this.state.selectedMarkerStyle = style;
                    this.updatePaletteSelection();
                });
                this.markerPaletteContainer.appendChild(item);
            });
            this.updatePaletteSelection();
        }

        updatePaletteSelection() {
            Array.from(this.markerPaletteContainer.children).forEach((item, index) => {
                item.classList.toggle('selected', this.markerStyles[index] === this.state.selectedMarkerStyle);
            });
        }
        
        bindEvents() {
            this.mainTextArea.addEventListener('mouseup', () => this.handleSelection());
            this.rulesTextArea.addEventListener('input', () => this.applyRules());
            this.docSelect.addEventListener('change', (e) => this.switchDocument(e.target.value));
            this.mainTextArea.addEventListener('click', (e) => this.handleMarkerClick(e));
            this.rulesHeader.addEventListener('click', () => this.toggleRulesPanel());
            this.speechBtn.addEventListener('click', () => this.toggleSpeech());
        }

        handleSelection() {
            // (v2.0ã‹ã‚‰å¤‰æ›´ãªã—)
            const selection = window.getSelection();
            if (!selection.rangeCount || selection.isCollapsed) return;
            const selectedText = selection.toString().trim();
            if (!selectedText) return;

            const range = selection.getRangeAt(0);
            const hiddenText = range.toString();

            const preRange = document.createRange();
            preRange.setStart(range.startContainer, 0);
            preRange.setEnd(range.startContainer, range.startOffset);
            const prefix = preRange.toString().slice(-this.state.anchorLength);

            const postRange = document.createRange();
            postRange.setStart(range.endContainer, range.endOffset);
            postRange.setEnd(range.endContainer, range.endContainer.length);
            const suffix = postRange.toString().slice(0, this.state.anchorLength);

            const styleString = `%% ${this.state.selectedMarkerStyle.type}${this.state.selectedMarkerStyle.value}`;
            const rule = `${this.state.currentDocId} :: ${prefix.trim()}...${suffix.trim()} -> ${hiddenText} ${styleString}`;
            
            this.rulesTextArea.value += (this.rulesTextArea.value ? '\n' : '') + rule;
            this.applyRules();
            selection.removeAllRanges();
        }

        handleMarkerClick(e) {
            // â˜…â˜…â˜… ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Œå…¨ã«ä¿®æ­£ â˜…â˜…â˜…
            const marker = e.target.closest('.marker');
            if (!marker) {
                this.clearAllReveals();
                return;
            }

            const currentTime = new Date().getTime();
            const timeSinceLastTap = currentTime - this.state.lastTap;

            if (timeSinceLastTap < 500 && this.state.lastClickedMarker === marker) {
                this.removeMarker(marker);
                this.state.lastTap = 0;
                this.state.lastClickedMarker = null;
            } else {
                // ä»–ã®ãƒãƒ¼ã‚«ãƒ¼ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ãŸã‚‰å…ƒã«æˆ»ã™
                this.clearAllReveals(marker); 
                // ã‚¯ãƒªãƒƒã‚¯ã—ãŸãƒãƒ¼ã‚«ãƒ¼ã®è¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹
                this.revealMarker(marker);
                
                this.state.lastTap = currentTime;
                this.state.lastClickedMarker = marker;
            }
        }
        
        revealMarker(marker) {
            // ç­”ãˆã‚’è¡¨ç¤º
            marker.classList.add('reveal');
            marker.textContent = marker.dataset.originalText;
        }

        unrevealMarker(marker) {
            // ãƒãƒ¼ã‚«ãƒ¼ã«æˆ»ã™
             marker.classList.remove('reveal');
            const styleString = marker.dataset.style;
            const type = styleString.charAt(0);
            const value = styleString.substring(1);
            const originalText = marker.dataset.originalText;
            if (type === 'E') {
                 marker.textContent = value.repeat(originalText.length);
            }
        }

        removeMarker(markerElement) {
            // (v2.0ã‹ã‚‰å¤‰æ›´ãªã—)
            const hiddenText = markerElement.dataset.originalText;
            const styleString = markerElement.dataset.style;
            
            // ã‚¢ãƒ³ã‚«ãƒ¼å†æ§‹ç¯‰ã®ãŸã‚ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’æ”¹å–„
            let prefix = '';
            let suffix = '';
            let prevNode = markerElement.previousSibling;
            while(prevNode && prevNode.nodeType === Node.TEXT_NODE && prefix.length < this.state.anchorLength) {
                prefix = prevNode.textContent + prefix;
                prevNode = prevNode.previousSibling;
            }
            let nextNode = markerElement.nextSibling;
            while(nextNode && nextNode.nodeType === Node.TEXT_NODE && suffix.length < this.state.anchorLength) {
                suffix += nextNode.textContent;
                nextNode = nextNode.nextSibling;
            }
            prefix = prefix.slice(-this.state.anchorLength).trim();
            suffix = suffix.slice(0, this.state.anchorLength).trim();

            const ruleToRemove = `${this.state.currentDocId} :: ${prefix}...${suffix} -> ${hiddenText} %% ${styleString}`;
            
            const rules = this.rulesTextArea.value.split('\n');
            const indexToRemove = rules.findIndex(line => line.trim() === ruleToRemove.trim());
            if (indexToRemove > -1) {
                rules.splice(indexToRemove, 1);
                this.rulesTextArea.value = rules.join('\n');
                this.applyRules();
            } else {
                console.warn("Could not find rule to remove:", ruleToRemove);
            }
        }

        applyRules() {
            // (v2.0ã‹ã‚‰ãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆéƒ¨åˆ†ã‚’ä¿®æ­£)
            const originalText = this.getOriginalText();
            this.state.documents[this.state.currentDocId] = originalText;
            this.mainTextArea.innerHTML = '';

            const allRules = this.rulesTextArea.value.split('\n').filter(line => line.trim() !== '');
            const targetRules = allRules.filter(line => line.startsWith(this.state.currentDocId + ' ::'));

            let segments = [{ text: originalText, type: 'text' }];

            targetRules.forEach(rule => {
                try {
                    const ruleParts = rule.split(' -> ');
                    const hiddenTextAndStyle = ruleParts[1].split(' %% ');
                    const hiddenText = hiddenTextAndStyle[0];
                    const styleString = hiddenTextAndStyle[1];
                    const anchorParts = ruleParts[0].split(' :: ')[1].split('...');
                    const prefix = anchorParts[0];
                    const suffix = anchorParts[1];

                    const fullAnchor = prefix + hiddenText + suffix;
                    
                    for (let i = 0; i < segments.length; i++) {
                        if (segments[i].type === 'text') {
                            const index = segments[i].text.indexOf(fullAnchor);
                            if (index > -1) {
                                const before = segments[i].text.substring(0, index + prefix.length);
                                const after = segments[i].text.substring(index + prefix.length + hiddenText.length);
                                
                                const newSegments = [];
                                if (before) newSegments.push({ text: before, type: 'text' });
                                newSegments.push({ text: hiddenText, type: 'marker', style: styleString });
                                if (after) newSegments.push({ text: after, type: 'text' });

                                segments.splice(i, 1, ...newSegments);
                                break; 
                            }
                        }
                    }
                } catch (e) { /* Rule parsing error */ }
            });

            segments.forEach(seg => {
                if (seg.type === 'text') {
                    this.mainTextArea.appendChild(document.createTextNode(seg.text));
                } else {
                    const markerSpan = document.createElement('span');
                    markerSpan.className = 'marker';
                    markerSpan.dataset.originalText = seg.text;
                    markerSpan.dataset.style = seg.style;
                    
                    const type = seg.style.charAt(0);
                    const value = seg.style.substring(1);
                    if (type === 'E') {
                        markerSpan.textContent = value.repeat(seg.text.length);
                    }
                    this.mainTextArea.appendChild(markerSpan);
                }
            });
            
            this.mainTextArea.innerHTML = this.mainTextArea.innerHTML.replace(/\n/g, '<br>');
            this.saveState();
        }

        toggleRulesPanel() {
            // (v2.0ã‹ã‚‰å¤‰æ›´ãªã—)
            this.rulesPanel.classList.toggle('closed');
            this.toggleRulesBtn.textContent = this.rulesPanel.classList.contains('closed') ? 'â–² é–‹ã' : 'â–¼ é–‰ã˜ã‚‹';
        }

        initSpeech() {
            // (v2.0ã‹ã‚‰å¤‰æ›´ãªã—)
            if (!('speechSynthesis' in window)) {
                this.speechBtn.disabled = true;
                this.speechBtn.textContent = "èª­ä¸Šä¸å¯";
                return;
            }
            const loadVoices = () => {
                this.state.voices = speechSynthesis.getVoices().filter(v => v.lang.startsWith('ja'));
                this.voiceSelect.innerHTML = '';
                this.state.voices.forEach(v => {
                    const option = document.createElement('option');
                    option.textContent = v.name;
                    this.voiceSelect.appendChild(option);
                });
            };
            speechSynthesis.onvoiceschanged = loadVoices;
            loadVoices();
        }

        toggleSpeech() {
            // (v2.0ã‹ã‚‰å¤‰æ›´ãªã—)
            if (this.state.isSpeaking) {
                speechSynthesis.cancel();
                this.state.isSpeaking = false;
                this.speechBtn.textContent = "â–¶ èª­ã¿ä¸Šã’";
                this.clearHighlight();
            } else {
                const textToSpeak = this.getOriginalText();
                if (!textToSpeak.trim()) return;

                const utterance = new SpeechSynthesisUtterance(textToSpeak);
                const selectedVoiceName = this.voiceSelect.value;
                const voice = this.state.voices.find(v => v.name === selectedVoiceName);
                if (voice) utterance.voice = voice;
                
                utterance.onboundary = (event) => {
                   if (event.name === 'word') {
                       this.highlightText(event.charIndex, event.charLength);
                   }
                };

                utterance.onend = () => {
                    this.state.isSpeaking = false;
                    this.speechBtn.textContent = "â–¶ èª­ã¿ä¸Šã’";
                    this.clearHighlight();
                };

                speechSynthesis.speak(utterance);
                this.state.isSpeaking = true;
                this.speechBtn.textContent = "â¹ åœæ­¢";
            }
        }

        highlightText(start, length) {
            // (v2.0ã‹ã‚‰å¤‰æ›´ãªã—)
            this.clearHighlight();
            let charCount = 0;
            const treeWalker = document.createTreeWalker(this.mainTextArea, Node.TEXT_NODE | Node.ELEMENT_NODE);
            
            const findTextNodes = (root) => {
                let nodes = [];
                for(const node of root.childNodes) {
                    if (node.nodeType === Node.TEXT_NODE) {
                        nodes.push(node);
                    } else if (node.nodeName === 'SPAN' && node.classList.contains('marker')) {
                        nodes.push(...findTextNodes(node));
                    }
                }
                return nodes;
            }
            
            const textNodes = findTextNodes(this.mainTextArea);
            
            for(const node of textNodes) {
                 const textLength = node.textContent.length;
                 if (charCount <= start && start < charCount + textLength) {
                     const range = document.createRange();
                     const startIndex = start - charCount;
                     const endIndex = Math.min(startIndex + length, textLength);
                     range.setStart(node, startIndex);
                     range.setEnd(node, endIndex);
                     const wrapper = document.createElement('span');
                     wrapper.className = 'speech-highlight';
                     try { range.surroundContents(wrapper); } catch (e) {}
                     break;
                 }
                 charCount += textLength;
            }
        }

        clearHighlight() {
            // (v2.0ã‹ã‚‰å¤‰æ›´ãªã—)
            const highlighted = this.mainTextArea.querySelector('.speech-highlight');
            if (highlighted) {
                const parent = highlighted.parentNode;
                while (highlighted.firstChild) {
                    parent.insertBefore(highlighted.firstChild, highlighted);
                }
                parent.removeChild(highlighted);
                parent.normalize();
            }
        }

        switchDocument(docId) {
            // (v2.0ã‹ã‚‰å¤‰æ›´ãªã—)
            if (this.state.isSpeaking) this.toggleSpeech();
            this.state.documents[this.state.currentDocId] = this.getOriginalText();
            this.state.currentDocId = docId;
            this.updateDocumentView();
            this.saveState();
        }
        
        updateDocumentView() {
            // (v2.0ã‹ã‚‰å¤‰æ›´ãªã—)
            this.docSelect.value = this.state.currentDocId;
            const text = this.state.documents[this.state.currentDocId] || `ã“ã‚Œã¯ã€Œ${this.docSelect.options[this.docSelect.selectedIndex].text}ã€ã§ã™ã€‚\nã“ã“ã«å­¦ç¿’ã—ãŸã„æ–‡ç« ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ã€‚`;
            this.mainTextArea.textContent = text;
            this.applyRules();
        }
        
        getOriginalText() {
            // (v2.0ã‹ã‚‰å¤‰æ›´ãªã—)
            const tempDiv = document.createElement('div');
            this.mainTextArea.childNodes.forEach(node => {
                if (node.nodeType === Node.TEXT_NODE) {
                    tempDiv.appendChild(node.cloneNode());
                } else if (node.nodeName === 'SPAN' && node.classList.contains('marker')) {
                    tempDiv.appendChild(document.createTextNode(node.dataset.originalText));
                } else if (node.nodeName === 'BR') {
                    tempDiv.appendChild(document.createTextNode('\n'));
                }
            });
            return tempDiv.textContent || '';
        }

        clearAllReveals(exceptThisOne = null) {
            // â˜…â˜…â˜… ãƒ­ã‚¸ãƒƒã‚¯ã‚’ä¿®æ­£ â˜…â˜…â˜…
            this.mainTextArea.querySelectorAll('.marker.reveal').forEach(m => {
                if (m !== exceptThisOne) {
                    this.unrevealMarker(m);
                }
            });
        }
        
        saveState() {
            // (v2.0ã‹ã‚‰å¤‰æ›´ãªã—)
            const dataToSave = {
                documents: this.state.documents,
                rules: this.rulesTextArea.value,
                currentDocId: this.state.currentDocId,
            };
            localStorage.setItem('markerToolState_v2_1', JSON.stringify(dataToSave));
        }

        loadState() {
            // (v2.0ã‹ã‚‰ãƒãƒ¼ã‚¸ãƒ§ãƒ³åã®ã¿å¤‰æ›´)
            const savedState = localStorage.getItem('markerToolState_v2_1');
            if (savedState) {
                const data = JSON.parse(savedState);
                this.state.documents = data.documents || {};
                this.rulesTextArea.value = data.rules || '';
                this.state.currentDocId = data.currentDocId || 'doc1';
            }
        }
    }

    new MarkerToolV2_1();
    </script>
</body>
</html>
