<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ»ãƒãƒ¼ã‚«ãƒ¼å¼æš—è¨˜ãƒ„ãƒ¼ãƒ« v2.0</title>
    <style>
        :root {
            --bg-color: #f4f4f9;
            --main-bg: #ffffff;
            --rule-bg: #eef1f5;
            --text-color: #333;
            --border-color: #d1d9e6;
            --header-bg: #4a6fa5;
            --header-text: #ffffff;
            --button-bg: #5a85c8;
            --highlight-bg: #fdff32;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Hiragino Sans', 'Noto Sans CJK JP', sans-serif;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        header {
            background-color: var(--header-bg);
            color: var(--header-text);
            padding: 10px 20px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex-shrink: 0;
            z-index: 10;
        }
        header h1 {
            font-size: 1.2em;
            margin: 0;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        select, input, button {
            font-size: 14px;
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: #f0f8ff;
        }
        button {
            background-color: var(--button-bg);
            color: var(--header-text);
            cursor: pointer;
            border-color: transparent;
        }
        button:hover {
            opacity: 0.9;
        }
        main {
            display: flex;
            flex-direction: column; /* ä¸Šä¸‹åˆ†å‰²ã«å¤‰æ›´ */
            flex-grow: 1;
            padding: 15px;
            gap: 15px;
            overflow: hidden;
        }
        .panel {
            background-color: var(--main-bg);
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .panel.main {
            flex-grow: 1;
        }
        .panel.rules {
            flex-shrink: 0;
            height: 150px; /* åˆæœŸé«˜ã• */
            transition: height 0.3s ease;
        }
        .panel.rules.closed {
            height: 40px; /* é–‰ã˜ãŸã¨ãã®é«˜ã• */
        }
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-color);
            background-color: #f9fafb;
            cursor: pointer;
        }
        .panel-header h2 {
            font-size: 1em;
            margin: 0;
        }
        textarea, #main-text-area {
            flex-grow: 1;
            border: none;
            padding: 15px;
            font-size: 18px;
            line-height: 1.8;
            resize: none;
            outline: none;
            background-color: transparent;
            font-family: inherit;
        }
        #main-text-area {
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-y: auto;
        }
        #rules-text-area {
            background-color: var(--rule-bg);
            font-family: monospace;
            font-size: 13px;
            line-height: 1.6;
        }
        .marker {
            cursor: pointer;
            border-radius: 3px;
            padding: 0.1em 0;
            transition: background-color 0.2s, color 0.2s;
            user-select: none;
        }
        .marker.reveal {
            color: var(--text-color) !important;
            background-color: var(--highlight-bg) !important;
            background-image: none !important;
        }
        .speech-highlight {
            background-color: var(--highlight-bg);
            border-radius: 3px;
        }
        .marker-palette {
            display: flex;
            gap: 5px;
            align-items: center;
            background-color: #e3eaf3;
            padding: 5px 8px;
            border-radius: 6px;
        }
        .palette-item {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
        }
        .palette-item.selected {
            border-color: #007bff;
            box-shadow: 0 0 5px rgba(0,123,255,0.5);
        }
    </style>
</head>
<body>
    <header>
        <h1>ãƒãƒ¼ã‚«ãƒ¼å¼æš—è¨˜ãƒ„ãƒ¼ãƒ« v2.0</h1>
        <div class="control-group">
            <label for="doc-select">æ–‡ç« :</label>
            <select id="doc-select">
                <option value="doc1">æ–‡ç« â‘ </option>
                <option value="doc2">æ–‡ç« â‘¡</option>
                <option value="doc3">æ–‡ç« â‘¢</option>
            </select>
        </div>
        <div class="control-group">
            <button id="speech-btn">â–¶ èª­ã¿ä¸Šã’</button>
            <select id="voice-select"></select>
        </div>
        <div class="marker-palette">
            <!-- ãƒãƒ¼ã‚«ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆãŒã“ã“ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
        </div>
    </header>

    <main>
        <div class="panel main">
             <div class="panel-header" style="cursor: default;">
                <h2>1. ã“ã“ã«æ–‡ç« ã‚’è²¼ã‚Šä»˜ã‘ã€ä¸‹ã®ãƒ‘ãƒ¬ãƒƒãƒˆã‹ã‚‰ãƒãƒ¼ã‚«ãƒ¼ã‚’é¸ã‚“ã§å¼•ã</h2>
            </div>
            <div id="main-text-area" contenteditable="true" spellcheck="false"></div>
        </div>
        <div class="panel rules" id="rules-panel">
            <div class="panel-header" id="rules-header">
                <h2>2. ãƒãƒ¼ã‚«ãƒ¼ã®ãƒ«ãƒ¼ãƒ« (ä»–ãƒ‡ãƒã‚¤ã‚¹ã«ã‚³ãƒ”ãƒšã§åŒæœŸ)</h2>
                <span id="toggle-rules-btn">â–¼ é–‰ã˜ã‚‹</span>
            </div>
            <textarea id="rules-text-area" placeholder="æ–‡ç« ã®ä¸Šã§ãƒ†ã‚­ã‚¹ãƒˆã‚’é¸æŠã—ã¦ãƒãƒ¼ã‚«ãƒ¼ã‚’å¼•ãã¨ã€ã“ã“ã«ãƒ«ãƒ¼ãƒ«ãŒè‡ªå‹•ç”Ÿæˆã•ã‚Œã¾ã™ã€‚"></textarea>
        </div>
    </main>

    <script>
    class MarkerToolV2 {
        constructor() {
            // DOMè¦ç´ 
            this.mainTextArea = document.getElementById('main-text-area');
            this.rulesTextArea = document.getElementById('rules-text-area');
            this.docSelect = document.getElementById('doc-select');
            this.speechBtn = document.getElementById('speech-btn');
            this.voiceSelect = document.getElementById('voice-select');
            this.rulesPanel = document.getElementById('rules-panel');
            this.rulesHeader = document.getElementById('rules-header');
            this.toggleRulesBtn = document.getElementById('toggle-rules-btn');
            
            // ãƒãƒ¼ã‚«ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ
            this.markerPaletteContainer = document.querySelector('.marker-palette');
            this.markerStyles = [
                { type: 'C', value: '#333333', display: 'âš«' }, // é»’
                { type: 'C', value: '#e53935', display: 'ğŸ”´' }, // èµ¤
                { type: 'C', value: '#1e88e5', display: 'ğŸ”µ' }, // é’
                { type: 'C', value: '#43a047', display: 'ğŸŸ¢' }, // ç·‘
                { type: 'E', value: 'ğŸ˜€', display: 'ğŸ˜€' },
                { type: 'E', value: 'â“', display: 'â“' },
                { type: 'E', value: 'ğŸ§ ', display: 'ğŸ§ ' }
            ];

            // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹
            this.state = {
                currentDocId: 'doc1',
                anchorLength: 7,
                documents: {},
                lastTap: 0,
                lastClickedMarker: null,
                selectedMarkerStyle: this.markerStyles[0],
                isSpeaking: false,
                voices: []
            };

            this.init();
        }

        init() {
            this.createMarkerPalette();
            this.loadState();
            this.initSpeech();
            this.bindEvents();
            this.updateDocumentView();
        }

        createMarkerPalette() {
            this.markerStyles.forEach((style, index) => {
                const item = document.createElement('div');
                item.className = 'palette-item';
                item.textContent = style.display;
                item.style.backgroundColor = style.type === 'C' ? style.value : 'transparent';
                if (style.type === 'C' && style.value === '#333333') item.style.color = '#fff';

                item.addEventListener('click', () => {
                    this.state.selectedMarkerStyle = style;
                    this.updatePaletteSelection();
                });
                this.markerPaletteContainer.appendChild(item);
            });
            this.updatePaletteSelection();
        }

        updatePaletteSelection() {
            Array.from(this.markerPaletteContainer.children).forEach((item, index) => {
                if (this.markerStyles[index] === this.state.selectedMarkerStyle) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
        }
        
        bindEvents() {
            this.mainTextArea.addEventListener('mouseup', () => this.handleSelection());
            this.rulesTextArea.addEventListener('input', () => this.applyRules());
            this.docSelect.addEventListener('change', (e) => this.switchDocument(e.target.value));
            this.mainTextArea.addEventListener('click', (e) => this.handleMarkerClick(e));
            this.rulesHeader.addEventListener('click', () => this.toggleRulesPanel());
            this.speechBtn.addEventListener('click', () => this.toggleSpeech());
        }

        // --- ä¸»è¦ãƒ­ã‚¸ãƒƒã‚¯ ---

        handleSelection() {
            const selection = window.getSelection();
            if (!selection.rangeCount || selection.isCollapsed) return;
            const selectedText = selection.toString().trim();
            if (!selectedText) return;

            const range = selection.getRangeAt(0);
            const hiddenText = range.toString();

            const preRange = document.createRange();
            preRange.setStart(range.startContainer, 0);
            preRange.setEnd(range.startContainer, range.startOffset);
            const prefix = preRange.toString().slice(-this.state.anchorLength);

            const postRange = document.createRange();
            postRange.setStart(range.endContainer, range.endOffset);
            postRange.setEnd(range.endContainer, range.endContainer.length);
            const suffix = postRange.toString().slice(0, this.state.anchorLength);

            const styleString = `%% ${this.state.selectedMarkerStyle.type}${this.state.selectedMarkerStyle.value}`;
            const rule = `${this.state.currentDocId} :: ${prefix.trim()}...${suffix.trim()} -> ${hiddenText} ${styleString}`;
            
            this.rulesTextArea.value += (this.rulesTextArea.value ? '\n' : '') + rule;
            this.applyRules();
            selection.removeAllRanges();
        }

        handleMarkerClick(e) {
            if (!e.target.classList.contains('marker')) {
                this.clearAllReveals();
                return;
            }
            const marker = e.target;
            const currentTime = new Date().getTime();
            const timeSinceLastTap = currentTime - this.state.lastTap;

            if (timeSinceLastTap < 500 && this.state.lastClickedMarker === marker) {
                this.removeMarker(marker);
                this.state.lastTap = 0;
                this.state.lastClickedMarker = null;
            } else {
                this.clearAllReveals();
                marker.classList.add('reveal');
                this.state.lastTap = currentTime;
                this.state.lastClickedMarker = marker;
            }
        }

        removeMarker(markerElement) {
            const hiddenText = markerElement.dataset.originalText;
            const styleString = markerElement.dataset.style;
            
            const parent = markerElement.parentNode;
            let fullText = parent.textContent;
            // Note: This logic for finding index is simple. More robust logic may be needed for complex cases.
            let tempText = "";
            for (const node of parent.childNodes) {
                if (node === markerElement) {
                    tempText += hiddenText;
                } else {
                    tempText += node.textContent;
                }
            }
            let markerIndex = tempText.indexOf(hiddenText);
            
            const prefix = tempText.substring(markerIndex - this.state.anchorLength, markerIndex).trim();
            const suffix = tempText.substring(markerIndex + hiddenText.length, markerIndex + hiddenText.length + this.state.anchorLength).trim();

            const ruleToRemove = `${this.state.currentDocId} :: ${prefix}...${suffix} -> ${hiddenText} %% ${styleString}`;
            
            const rules = this.rulesTextArea.value.split('\n');
            // A more robust removal logic to handle potential duplicate-looking rules
            const indexToRemove = rules.findIndex(line => line.trim() === ruleToRemove.trim());
            if (indexToRemove > -1) {
                rules.splice(indexToRemove, 1);
                this.rulesTextArea.value = rules.join('\n');
                this.applyRules();
            }
        }

        applyRules() {
            const originalText = this.getOriginalText();
            this.state.documents[this.state.currentDocId] = originalText;
            this.mainTextArea.innerHTML = '';

            const allRules = this.rulesTextArea.value.split('\n').filter(line => line.trim() !== '');
            const targetRules = allRules.filter(line => line.startsWith(this.state.currentDocId + ' ::'));

            let segments = [{ text: originalText, type: 'text' }];

            targetRules.forEach(rule => {
                try {
                    const ruleParts = rule.split(' -> ');
                    const hiddenTextAndStyle = ruleParts[1].split(' %% ');
                    const hiddenText = hiddenTextAndStyle[0];
                    const styleString = hiddenTextAndStyle[1];
                    const anchorParts = ruleParts[0].split(' :: ')[1].split('...');
                    const prefix = anchorParts[0];
                    const suffix = anchorParts[1];

                    const fullAnchor = prefix + hiddenText + suffix;
                    
                    for (let i = 0; i < segments.length; i++) {
                        if (segments[i].type === 'text') {
                            const index = segments[i].text.indexOf(fullAnchor);
                            if (index > -1) {
                                const before = segments[i].text.substring(0, index + prefix.length);
                                const after = segments[i].text.substring(index + prefix.length + hiddenText.length);
                                
                                const newSegments = [];
                                if (before) newSegments.push({ text: before, type: 'text' });
                                newSegments.push({ text: hiddenText, type: 'marker', style: styleString });
                                if (after) newSegments.push({ text: after, type: 'text' });

                                segments.splice(i, 1, ...newSegments);
                                break; 
                            }
                        }
                    }
                } catch (e) { console.error("Rule parsing error:", e); }
            });

            segments.forEach(seg => {
                if (seg.type === 'text') {
                    this.mainTextArea.appendChild(document.createTextNode(seg.text));
                } else {
                    const markerSpan = document.createElement('span');
                    markerSpan.className = 'marker';
                    markerSpan.dataset.originalText = seg.text;
                    markerSpan.dataset.style = seg.style;
                    
                    const type = seg.style.charAt(0);
                    const value = seg.style.substring(1);
                    if (type === 'C') {
                        markerSpan.style.backgroundColor = value;
                        markerSpan.style.color = 'transparent';
                        markerSpan.textContent = " ".repeat(seg.text.length).replace(/ /g, '\u00A0');
                    } else if (type === 'E') {
                        markerSpan.textContent = value.repeat(seg.text.length);
                        markerSpan.style.color = '#333';
                        markerSpan.style.letterSpacing = '0.1em';
                    }

                    this.mainTextArea.appendChild(markerSpan);
                }
            });
            
            this.mainTextArea.innerHTML = this.mainTextArea.innerHTML.replace(/\n/g, '<br>');
            this.saveState();
        }

        // --- UI & èª­ã¿ä¸Šã’ ---

        toggleRulesPanel() {
            this.rulesPanel.classList.toggle('closed');
            this.toggleRulesBtn.textContent = this.rulesPanel.classList.contains('closed') ? 'â–² é–‹ã' : 'â–¼ é–‰ã˜ã‚‹';
        }

        initSpeech() {
            if (!('speechSynthesis' in window)) {
                this.speechBtn.disabled = true;
                this.speechBtn.textContent = "èª­ä¸Šä¸å¯";
                return;
            }
            speechSynthesis.onvoiceschanged = () => {
                this.state.voices = speechSynthesis.getVoices().filter(v => v.lang.startsWith('ja'));
                this.voiceSelect.innerHTML = '';
                this.state.voices.forEach(v => {
                    const option = document.createElement('option');
                    option.textContent = v.name;
                    this.voiceSelect.appendChild(option);
                });
            };
            // Initial load
            setTimeout(() => speechSynthesis.onvoiceschanged(), 100);
        }

        toggleSpeech() {
            if (this.state.isSpeaking) {
                speechSynthesis.cancel();
                this.state.isSpeaking = false;
                this.speechBtn.textContent = "â–¶ èª­ã¿ä¸Šã’";
            } else {
                const textToSpeak = this.getOriginalText();
                if (!textToSpeak.trim()) return;

                const utterance = new SpeechSynthesisUtterance(textToSpeak);
                const selectedVoiceName = this.voiceSelect.value;
                const voice = this.state.voices.find(v => v.name === selectedVoiceName);
                if (voice) utterance.voice = voice;
                
                let charIndex = 0;
                utterance.onboundary = (event) => {
                    if (event.name === 'word') {
                       this.highlightText(event.charIndex, event.charLength);
                    }
                };

                utterance.onend = () => {
                    this.state.isSpeaking = false;
                    this.speechBtn.textContent = "â–¶ èª­ã¿ä¸Šã’";
                    this.clearHighlight();
                };

                speechSynthesis.speak(utterance);
                this.state.isSpeaking = true;
                this.speechBtn.textContent = "â¹ åœæ­¢";
            }
        }

        highlightText(start, length) {
            this.clearHighlight();
            const originalText = this.getOriginalText();
            // A simplified highlight logic. Might need refinement.
            const wrapper = document.createElement('span');
            wrapper.className = 'speech-highlight';

            const range = document.createRange();
            let currentNode, charCount = 0;
            const treeWalker = document.createTreeWalker(this.mainTextArea, Node.TEXT_NODE);
            
            while(currentNode = treeWalker.nextNode()) {
                const textLength = currentNode.textContent.length;
                if (charCount + textLength > start) {
                    const startIndex = start - charCount;
                    const endIndex = Math.min(startIndex + length, textLength);
                    range.setStart(currentNode, startIndex);
                    range.setEnd(currentNode, endIndex);
                    try {
                        range.surroundContents(wrapper);
                    } catch(e) { /* ignore overlapping issues */ }
                    break;
                }
                charCount += textLength;
            }
        }

        clearHighlight() {
            const highlighted = this.mainTextArea.querySelector('.speech-highlight');
            if (highlighted) {
                const parent = highlighted.parentNode;
                while (highlighted.firstChild) {
                    parent.insertBefore(highlighted.firstChild, highlighted);
                }
                parent.removeChild(highlighted);
                parent.normalize(); // Merge text nodes
            }
        }

        // --- è£œåŠ©é–¢æ•° & çŠ¶æ…‹ç®¡ç† ---
        
        switchDocument(docId) {
            if (this.state.isSpeaking) this.toggleSpeech();
            this.state.documents[this.state.currentDocId] = this.getOriginalText();
            this.state.currentDocId = docId;
            this.updateDocumentView();
            this.saveState();
        }
        
        updateDocumentView() {
            this.docSelect.value = this.state.currentDocId;
            const text = this.state.documents[this.state.currentDocId] || `ã“ã‚Œã¯ã€Œ${this.docSelect.options[this.docSelect.selectedIndex].text}ã€ã§ã™ã€‚\nã“ã“ã«å­¦ç¿’ã—ãŸã„æ–‡ç« ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ã€‚`;
            this.mainTextArea.textContent = text;
            this.applyRules();
        }
        
        getOriginalText() {
            const tempDiv = document.createElement('div');
            // This is a complex part: we need to reconstruct text from markers
            this.mainTextArea.childNodes.forEach(node => {
                if (node.nodeType === Node.TEXT_NODE) {
                    tempDiv.appendChild(node.cloneNode());
                } else if (node.nodeName === 'SPAN' && node.classList.contains('marker')) {
                    tempDiv.appendChild(document.createTextNode(node.dataset.originalText));
                } else if (node.nodeName === 'BR') {
                    tempDiv.appendChild(document.createTextNode('\n'));
                }
            });
            return tempDiv.textContent || '';
        }

        clearAllReveals() {
            this.mainTextArea.querySelectorAll('.marker.reveal').forEach(m => m.classList.remove('reveal'));
        }

        saveState() {
            const dataToSave = {
                documents: this.state.documents,
                rules: this.rulesTextArea.value,
                currentDocId: this.state.currentDocId,
            };
            localStorage.setItem('markerToolState_v2', JSON.stringify(dataToSave));
        }

        loadState() {
            const savedState = localStorage.getItem('markerToolState_v2');
            if (savedState) {
                const data = JSON.parse(savedState);
                this.state.documents = data.documents || {};
                this.rulesTextArea.value = data.rules || '';
                this.state.currentDocId = data.currentDocId || 'doc1';
            }
        }
    }

    new MarkerToolV2();
    </script>
</body>
</html>
